<!DOCTYPE html
<!-- based off https://bl.ocks.org/heybignick/3faf257bbbbc7743bb72310d03b86ee8 -->
<meta charset="utf-8">
<style>

.links line {
  stroke: #999;
  stroke-opacity: 0.6;
}

.nodes circle {
  stroke: #fff;
  stroke-width: 1.5px;
}

text {
  font-family: sans-serif;
  font-size: 15px;
}
svg {
 border:10px solid green;
}

</style>
<h1>Medium Network</h1>
<!-- visualization area -->
<svg id="visualization" height="800" width="1200" margin="auto"></svg>

<!-- Check box -->
<div>
    <input type="checkbox" id="checkbox" checked>
      <label for="myCheckBox">Developer Mode</label>
</div>

<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="node-pie.js"></script>
<script>

var svg = d3.select("svg"),
    width = +svg.attr("width"),
    height = +svg.attr("height"),
    radius = 20;

var color = d3.scaleOrdinal(d3.schemeCategory20)

var simulation = d3.forceSimulation()
    .force("link", d3.forceLink().id(function(d) { return d.id; }).distance(function(d){
        if (d.invisible) {
            return 0;
        } else {
            return 200
        }}).iterations(1))
    .force("charge", d3.forceManyBody()
                            .strength(-300)
                            .distanceMax(height))

    .force("center", d3.forceCenter(width / 2, height / 2))
    .force("collide", d3.forceCollide(function(d) { return d.postCount/10000}).strength(10).iterations(1));

function getTextWidth(text) {
    // font = font = d3.select('text').style('font-size') + ' ' + d3.select('text').style('font-family')
    font = '15px sans-serif'
    // re-use canvas object for better performance
    var canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement("canvas"));
    var context = canvas.getContext("2d");
    context.font = font;
    var metrics = context.measureText(text);
    return metrics.width;
}
var development_color = 'red'
var link_color = '#999'
// checkbox
function update(){
	if(d3.select("#checkbox").property("checked")){
        d3.selectAll('circle')
            .style('stroke', development_color);
        d3.selectAll('.links').selectAll("line")
        .style('stroke', function() {
            return this.style.stroke == 'none' ? development_color:link_color});
    }
	else {
        d3.selectAll('circle')
        .style('stroke', 'none');
        d3.selectAll('.links').selectAll("line")
        .style('stroke', function(){
            return this.style.stroke == development_color ? 'none':link_color
        });
        }
        }
update();
d3.select("#checkbox").on("change",update);

// read in data
d3.json("music_health_life.json", function(error, graph) {
  if (error) throw error;

  // add dummy nodes and links for the text
  graph.nodes.forEach((item, i) => {
      text_width = getTextWidth(item['id'])
      radius = item['postCount']/10000
      if (text_width <= 2*radius) {
          item['text'] = item['id']
          item['text_width'] = text_width
      } else {
          graph.nodes.push({'id':item['id']+'_label','text':item['id'], 'group':null, 'postCount':item['postCount'],'text_width':text_width})
          graph.links.push({'source':item['id']+'_label','target':item['id'], "invisible":true})
      }

  });

  //add encompassing group for the zoom
  var g = svg.append("g")
    .attr("class", "everything");

  var link = g.append("g")
    .attr("class", "links")
    .selectAll("line")
    .data(graph.links)
    .enter().append("line")
    .attr("stroke-width", 2)
    .style("stroke", function(d){
        if (d.invisible) {
            return development_color
        }
    } )
    .attr('length', 0)

  var node = g.append("g")
    .attr("class", "nodes")
    .selectAll("circle")
    .data(graph.nodes)
    .enter().append("g")

  var circles = node.append("circle")
      .attr("r", function(d){
          if (d.group==null) {
            return d.text_width/2
        } else {
            return d.postCount/10000
        }

      })
      .attr("fill", function(d) {
          if (d.group==null) {
              return "none"
          }else {
              return color(d.group);
          } })
      .style("stroke", development_color)


  var labels = node.append("text")
        .text(function(d) {
          return d.text;
        })
        .attr("text-anchor", "middle")
        .attr("dy", ".35em")

  node.append("title")
      .text(function(d) { return d.id; });

// simulation
  simulation
      .nodes(graph.nodes)
      .on("tick", ticked);
  simulation.force("link")
      .links(graph.links);


  function ticked() {
    link
        .attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });

    node
        .attr("transform", function(d) {
          return "translate(" + d.x + "," + d.y + ")";
      });
  }

  var zoom_handler = d3.zoom()
    .on("zoom", zoom_actions);

    zoom_handler(svg)
      //Zoom functions
    function zoom_actions(){
        g.attr("transform", d3.event.transform)
}
});



</script>
